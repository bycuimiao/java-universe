#《java并发编程实战》
##第一章
    1、进程之间粗粒度的通信机制来交互数据的方式：套接字、信号处理器、共享内存、信号量以及文件
    2、线程带来的风险
 	    a、安全性问题：
 	    b、活跃性问题：包括死锁，饥饿，活锁等。活跃性意味着某件正确的事情最终会发生
 	    c、性能问题：上下文切换操作
    3、servlet是线程安全的
##第二章：线程安全性
    1、线程安全性最核心的概念是正确性
    2、正确性的含义是：某个类的行为与其规范完全一致
    3、单线程的正确性近似定义为“所见即所知”
    4、线程安全性定义：当多个线程访问某个类的时候，这个类始终能表现出正确的行为，那么就称这个类是线程安全的
    5、在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施
    6、无状态的对象一定是线程安全的
    7、最常见竞态条件类型：先检查后执行
    8、大多数静态条件的本质：基于一种可能失效的观察结果来做出判断或者执行某个计算
    9、重入意味着获取锁的操作的粒度是“线程”，而不是“调用”
##第三章：对象的共享
    1、当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机的值。这种安全性保证也成为最低安全性。
    2、最低安全性适用于绝大多数变量，但有一个例外：非volatile类型的64位数值变量(double，long)。java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或者写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用volatile来声明他们，或者用锁保护起来。
    3、volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新的写入的值。
    4、volatile 写和读的内存语义: 
    线程 A 写一个 volatile 变量,实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了(其对共享变量所在修改的)消息。 
    线程 B 读一个 volatile 变量,实质上是线程 B 接收了之前某个线程发出的(在写这个 volatile 变量之前对共享变量所做修改的)消息。
    线程 A 写一个 volatile 变量,随后线程 B 读这个 volatile 变量,这个过程实质上是线程 A 通过主内存向线程 B 发送消息。
    5、volatile变量通常用做某个操作完成、发生、中断或者状态的标志
    6、加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能保证可见性
    7、发布与逸出
    8、线程封闭：实现线程安全性的最简单方法之一。在单线程内访问共享的可变数据，不需要同步。这种方法叫线程封闭
    9、线程封闭技术的一种常见应用是JDBC的Connection对象。线程池只将连接分配给单个线程，不会把他再分配给其他线程调用。
    10、栈封闭
    11、维持线程封闭性的一种更规范方法是使用ThreadLocal，这个类能使线程中的某个值与保持值的对象关联起来。
    12、你可以将ThreadLocal<T>视为Map<Thread,T>对象
    13、不可变对象一定是线程安全的
    14、即使对象中所有的域都是final类型的，这个对象仍然是可变的，因为在final类型的域中可以保存对可变对象的引用
    15、当满足以下条件的时候，对象才是不可变的：
        a、对象创建以后其状态就不能修改
        b、对象的所有域都是final类型的
        c、对象是正确创造的(在对象的创建期间，this引用没有逸出)
    16、final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无需同步
    17、两个编程好习惯，第一个早已经成为习惯，第二个还偶尔忘记
        a、除非需要更高的可见性，否则应该将所有的域声明为私有域
        b、除非需要某个域是可变的，否则应将其声明为final域
    18、任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。
    19、要安全的发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全的发布：
        a、在静态初始化函数中初始化一个对象引用
        b、将对象的引用保存到volatile类型的域或者AtomicReferance对象中
        c、将对象的引用保存到某个正确构造对象的final域中
        d、将对象的引用保存到个由锁保护的域中(例如将对象放入Vector或synchronizedList)
    20、静态初始化器邮JVM在类的初始化阶段执行，由于在JVM内部存在着同步机制，因此通过这种方式初始化的任何对象都可以安全的发布
    21、在没有额外的同步的情况下，任何线程都可以安全的使用被安全发布的事实不可变对象
    22、对象的发布需求取决于它的可变性：
        a、不可变对象可以通过任意机制来发布
        b、事实不可变对象必须通过安全方式来发布
        c、可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。
##第四章：对象的组合
    1、实例封闭是构建线程安全类的一个最简单方式
    2、java监视器模式:Vector和Hashtable
    3、@Guarded注解标志着 该操作需要获得锁才能实现安全的院子操作
    4、SimpleDateFormat不是线程安全的
##第五章：基础构建模块
    1、如果不希望在迭代期间加锁，那么一种代替方案就是“克隆”容器，并在副本上进行迭代
    2、容器的hashCode和equals等方法也会间接执行迭代操作，当容器作为另一个容器的键值时，就会出现这种情况。同样，containsAll、removeAll和retainAll等方法以及把容器作为参数的构造函数，都会对容器进行迭代。这些迭代都可能抛出ConcurrentModificationException
    3、ConcurrentHashMap返回的迭代器具有弱一致性，并非及时失败
    4、ConcurrentHashMap的size返回的是一个估计值。
    5、CopyOnWriteArrayList 写入时复制，不会抛出ConcurrentModificationException异常，仅当迭代操作远远多于修改操作时才应该使用CopyOnWriteArrayList
    6、生产者-消费者模式将生产数据的过程与使用数据的过程解耦开来以简化工作负载的管理
    7、双端队列与工作密取
    8、Collections.synchronizedXxx等工厂方法实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每一次只有一个线程能访问容器的状态
    9、在单线程情况下也可能抛出ConcurrentModificationException异常。当对象直接从容器中删除而不是通过Iterator.remove来删除时，就会抛出这个异常。
    10、“写入时复制(Copy-On-Write)”容器的线程安全性在于，只要正确发布了一个事实不可变对象，那么在访问该对象时就不再需要进一步同步。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。不会抛出ConcurrentModificationException异常。每当修改容器时都会复制底层数组，这需要一定的开销。仅当迭代操作远远多于修改操作时，才应该用写入时复制容器。应用场景：在分发通知时需要迭代已注册监听器列表，并调用每一个监听器，在大多数情况下，注册和注销事件监听器的操作远少于接收事件通知的操作。
##第六章
    1、你已经拥有足够多的线程使所有cpu保持忙碌，那么再创建更多的线程反而会降低性能
    2、Executor扩展了ExecutorService接口，解决Executor生命周期问题。shutdown方法平缓关闭，shutdownNow粗暴关闭
    第七章
    1、Java没有提供任何机制来安全地终止线程。但他提供了中断，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。
    2、对中断(interrupt)操作的正确理解是：他不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己(这些时刻也叫取消点)。
    3、通常中断是实现取消最合理的方式
    4、批评者曾嘲笑java的中断功能，因为他没有给出抢占式中断机制，而且还强迫开发人员必须处理InterruptedException。然而，通过推迟中断请求的处理，开发人员能制定更灵活的中断策略，从而使应用程序在响应性和健壮性之间实现合理的平衡
    5、